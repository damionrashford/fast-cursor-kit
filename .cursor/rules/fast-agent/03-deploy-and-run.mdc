---
description: Deployment options including interactive mode, command-line execution, and MCP server deployment
globs: ["**/*.py", "**/*.sh", "**/*.bash"]
alwaysApply: true
---

# Deploy and Run

**fast-agent** provides flexible deployment options to meet a variety of use cases, from interactive development to production server deployments.

## Interactive Mode

Run **fast-agent** programs interactively for development, debugging, or direct user interaction.

```python
import asyncio
from mcp_agent.core.fastagent import FastAgent

fast = FastAgent("My Interactive Agent")

@fast.agent(instruction="You are a helpful assistant")
async def main():
    async with fast.run() as agent:
        # Start interactive prompt
        await agent()

if __name__ == "__main__":
    asyncio.run(main())
```

When started with `uv run agent.py`, this begins an interactive prompt where you can chat directly with the configured agents, apply prompts, save history and so on.

## Command Line Execution

**fast-agent** supports command-line arguments to run agents and workflows with specific messages.

```bash
# Send a message to a specific agent
uv run agent.py --agent default --message "Analyze this dataset"

# Override the default model
uv run agent.py --model gpt-4o --agent default --message "Complex question"

# Run with minimal output
uv run agent.py --quiet --agent default --message "Background task"
```

This is perfect for scripting, automation, or one-off queries.

The `--quiet` flag switches off the Progress, Chat and Tool displays.

## MCP Server Deployment

Any **fast-agent** application can be deployed as an MCP server with a simple command-line switch.

### Starting an MCP Server

```bash
# Start as a Streamable HTTP server (http://localhost:8080/mcp)
uv run agent.py --server --transport http --port 8080

# Start as an SSE server (http://localhost:8080/sse)
uv run agent.py --server --transport sse --port 8080

# Start as a stdio server
uv run agent.py --server --transport stdio
```

Each agent exposes an MCP Tool for sending messages to the agent, and a Prompt that returns the conversation history.

This enables cross-agent state transfer via the MCP Prompts.

The MCP Server can also be started programatically.

### Programmatic Server Startup

```python
import asyncio
from mcp_agent.core.fastagent import FastAgent

fast = FastAgent("Server Agent")

@fast.agent(instruction="You are an API agent")
async def main():
    # Start as a server programmatically
    await fast.start_server(
        transport="sse",
        host="0.0.0.0",
        port=8080,
        server_name="API-Agent-Server",
        server_description="Provides API access to my agent"
    )

if __name__ == "__main__":
    asyncio.run(main())
```

## Python Program Integration

Embed **fast-agent** into existing Python applications to add MCP agent capabilities.

```python
import asyncio
from mcp_agent.core.fastagent import FastAgent

fast = FastAgent("Embedded Agent")

@fast.agent(instruction="You are a data analysis assistant")
async def analyze_data(data):
    async with fast.run() as agent:
        result = await agent.send(f"Analyze this data: {data}")
        return result

# Use in your application
async def main():
    user_data = get_user_data()
    analysis = await analyze_data(user_data)
    display_results(analysis)

if __name__ == "__main__":
    asyncio.run(main())
```

## Deployment Options Summary

### 1. Interactive Development
- **Use Case**: Development, debugging, testing
- **Command**: `uv run agent.py`
- **Features**: Full interactive chat, tool display, progress tracking

### 2. Command Line Automation
- **Use Case**: Scripting, automation, one-off tasks
- **Command**: `uv run agent.py --message "task" --quiet`
- **Features**: Minimal output, programmatic integration

### 3. MCP Server (HTTP/SSE)
- **Use Case**: Web applications, API services
- **Command**: `uv run agent.py --server --transport http --port 8080`
- **Features**: RESTful API, real-time streaming, cross-platform access

### 4. MCP Server (STDIO)
- **Use Case**: Local tool integration, CLI tools
- **Command**: `uv run agent.py --server --transport stdio`
- **Features**: Standard input/output, tool integration

### 5. Embedded Application
- **Use Case**: Existing Python applications
- **Method**: Import and use FastAgent class directly
- **Features**: Full programmatic control, custom integration

## Server Configuration Options

### Transport Protocols

| Protocol | Use Case | URL Format | Features |
|----------|----------|------------|----------|
| HTTP | Web APIs, REST services | `http://host:port/mcp` | RESTful, stateless |
| SSE | Real-time streaming | `http://host:port/sse` | Server-sent events, streaming |
| STDIO | Local tools, CLI | Standard input/output | Direct integration |

### Server Parameters

```python
await fast.start_server(
    transport="sse",                    # "http", "sse", or "stdio"
    host="0.0.0.0",                     # Server host address
    port=8080,                          # Server port (for HTTP/SSE)
    server_name="My Agent Server",      # Custom server name
    server_description="Description"    # Server description
)
```

## Command Line Options for Deployment

### Basic Options
- `--server`: Enable server mode
- `--transport {http,sse,stdio}`: Choose transport protocol
- `--port PORT`: Set port number (default: 8000)
- `--host HOST`: Set host address (default: 0.0.0.0)

### Agent Selection
- `--agent AGENT`: Specify which agent to use (default: "default")
- `--model MODEL`: Override the default model

### Output Control
- `--quiet`: Disable progress display and logging
- `--message MESSAGE`: Send a single message and exit

### Examples

```bash
# Interactive development
uv run agent.py

# Command line automation
uv run agent.py --agent researcher --message "Analyze this topic" --quiet

# HTTP server deployment
uv run agent.py --server --transport http --port 8080 --agent api_agent

# SSE server for real-time applications
uv run agent.py --server --transport sse --port 9000

# STDIO server for tool integration
uv run agent.py --server --transport stdio
```

## Integration Patterns

### Web Application Integration

```python
from fastapi import FastAPI
from mcp_agent.core.fastagent import FastAgent

app = FastAPI()
fast = FastAgent("Web Agent", parse_cli_args=False)

@fast.agent(instruction="You are a web API assistant")
async def web_agent():
    pass

@app.post("/chat")
async def chat_endpoint(message: str):
    async with fast.run() as agent:
        response = await agent.web_agent.send(message)
        return {"response": response}
```

### CLI Tool Integration

```python
import click
from mcp_agent.core.fastagent import FastAgent

fast = FastAgent("CLI Agent", parse_cli_args=False)

@fast.agent(instruction="You are a CLI assistant")
async def cli_agent():
    pass

@click.command()
@click.option('--message', '-m', required=True, help='Message to send')
def main(message):
    async with fast.run() as agent:
        response = asyncio.run(agent.cli_agent.send(message))
        click.echo(response)

if __name__ == '__main__':
    main()
```

## Best Practices

### Development Workflow
1. Start with interactive mode for development and testing
2. Use command line mode for automation and scripting
3. Deploy as MCP server for production use

### Production Deployment
- Use HTTP/SSE transport for web applications
- Use STDIO transport for CLI tools
- Implement proper error handling and logging
- Consider using reverse proxies for HTTP servers

### Security Considerations
- Use authentication for HTTP/SSE servers
- Validate input messages
- Implement rate limiting for production deployments
- Use HTTPS in production environments

---

*Source: [https://fast-agent.ai/agents/running/](https://fast-agent.ai/agents/running/)*
