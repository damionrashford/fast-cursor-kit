# FastAPI Features

## Path Operations

### HTTP Methods
FastAPI supports all standard HTTP methods:

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/items/")        # GET - Read data
def read_items():
    return {"items": []}

@app.post("/items/")       # POST - Create data
def create_item(item: Item):
    return item

@app.put("/items/{id}")    # PUT - Update data
def update_item(id: int, item: Item):
    return {"id": id, "item": item}

@app.delete("/items/{id}") # DELETE - Remove data
def delete_item(id: int):
    return {"deleted": id}

@app.patch("/items/{id}")  # PATCH - Partial update
def patch_item(id: int, item: Item):
    return {"id": id, "item": item}

@app.head("/items/")       # HEAD - Headers only
def head_items():
    return {"headers": "only"}

@app.options("/items/")    # OPTIONS - CORS preflight
def options_items():
    return {"options": "available"}
```

### Path Parameters
```python
@app.get("/items/{item_id}")
def read_item(item_id: int):
    return {"item_id": item_id}

# Path parameters with validation
@app.get("/items/{item_id}")
def read_item(item_id: int, q: str | None = None):
    return {"item_id": item_id, "q": q}
```

### Query Parameters
```python
@app.get("/items/")
def read_items(skip: int = 0, limit: int = 100):
    return {"skip": skip, "limit": limit}

# Optional query parameters
@app.get("/items/")
def read_items(skip: int = 0, limit: int | None = None):
    return {"skip": skip, "limit": limit}

# Query parameter validation
from fastapi import Query

@app.get("/items/")
def read_items(
    q: str | None = Query(default=None, min_length=3, max_length=50),
    skip: int = Query(default=0, ge=0),
    limit: int = Query(default=100, le=1000)
):
    return {"q": q, "skip": skip, "limit": limit}
```

## Request Body

### Pydantic Models
```python
from pydantic import BaseModel, Field
from typing import Optional

class Item(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    description: Optional[str] = Field(None, max_length=1000)
    price: float = Field(..., gt=0)
    tax: Optional[float] = None
    tags: list[str] = []

class User(BaseModel):
    username: str
    full_name: Optional[str] = None
    email: str
    disabled: Optional[bool] = None

@app.post("/items/")
def create_item(item: Item):
    return item

@app.post("/users/")
def create_user(user: User):
    return user
```

### Nested Models
```python
class Address(BaseModel):
    street: str
    city: str
    country: str

class User(BaseModel):
    name: str
    email: str
    address: Address
    age: int

@app.post("/users/")
def create_user(user: User):
    return user
```

### Model Validation
```python
from pydantic import BaseModel, Field, EmailStr
from typing import Optional

class User(BaseModel):
    username: str = Field(..., min_length=3, max_length=50)
    email: EmailStr
    full_name: Optional[str] = Field(None, max_length=100)
    age: int = Field(..., ge=0, le=120)
    is_active: bool = True
```

## Response Models

### Response Model Declaration
```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: list[str] = []

class ItemResponse(BaseModel):
    id: int
    name: str
    price: float
    tags: list[str]

@app.post("/items/", response_model=ItemResponse)
def create_item(item: Item):
    # FastAPI will automatically filter the response
    return {"id": 1, "name": item.name, "price": item.price, "tags": item.tags}
```

### Response Status Codes
```python
from fastapi import FastAPI, HTTPException, status

@app.post("/items/", status_code=status.HTTP_201_CREATED)
def create_item(item: Item):
    return item

@app.get("/items/{item_id}")
def read_item(item_id: int):
    if item_id == 0:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Item not found"
        )
    return {"item_id": item_id}
```

## Form Data and Files

### Form Data
```python
from fastapi import Form

@app.post("/login/")
def login(username: str = Form(), password: str = Form()):
    return {"username": username}

# Multiple form fields
@app.post("/users/")
def create_user(
    name: str = Form(),
    age: int = Form(),
    email: str = Form()
):
    return {"name": name, "age": age, "email": email}
```

### File Uploads
```python
from fastapi import File, UploadFile

@app.post("/files/")
def create_file(file: bytes = File()):
    return {"file_size": len(file)}

@app.post("/uploadfile/")
def create_upload_file(file: UploadFile):
    return {"filename": file.filename}

# Multiple files
@app.post("/files/")
def create_files(files: list[bytes] = File()):
    return {"file_sizes": [len(file) for file in files]}

@app.post("/uploadfiles/")
def create_upload_files(files: list[UploadFile]):
    return {"filenames": [file.filename for file in files]}
```

## Dependencies

### Function Dependencies
```python
from fastapi import Depends

def get_db():
    db = DBSession()
    try:
        yield db
    finally:
        db.close()

@app.get("/users/")
def read_users(db: Session = Depends(get_db)):
    users = db.query(User).all()
    return users
```

### Class Dependencies
```python
class Database:
    def __init__(self):
        self.connection = "database_connection"
    
    def get_data(self):
        return {"data": "from database"}

def get_database():
    return Database()

@app.get("/data/")
def read_data(db: Database = Depends(get_database)):
    return db.get_data()
```

### Dependency with Parameters
```python
def get_user_by_token(token: str = Depends(oauth2_scheme)):
    user = fake_decode_token(token)
    if not user:
        raise HTTPException(status_code=400, detail="Invalid token")
    return user

@app.get("/users/me/")
def read_users_me(current_user: User = Depends(get_user_by_token)):
    return current_user
```

## Security

### OAuth2 with Password Flow
```python
from fastapi import Depends, FastAPI, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

@app.post("/token")
def login(form_data: OAuth2PasswordRequestForm = Depends()):
    user = authenticate_user(form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token = create_access_token(data={"sub": user.username})
    return {"access_token": access_token, "token_type": "bearer"}

@app.get("/users/me/")
def read_users_me(current_user: User = Depends(get_current_user)):
    return current_user
```

### JWT Tokens
```python
from datetime import datetime, timedelta
from jose import JWTError, jwt

SECRET_KEY = "your-secret-key"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

def create_access_token(data: dict):
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def verify_token(token: str = Depends(oauth2_scheme)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    return username
```

## Middleware

### CORS Middleware
```python
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

### Custom Middleware
```python
from fastapi import Request
import time

@app.middleware("http")
async def add_process_time_header(request: Request, call_next):
    start_time = time.time()
    response = await call_next(request)
    process_time = time.time() - start_time
    response.headers["X-Process-Time"] = str(process_time)
    return response
```

## WebSockets

### Basic WebSocket
```python
from fastapi import WebSocket, WebSocketDisconnect

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    try:
        while True:
            data = await websocket.receive_text()
            await websocket.send_text(f"Message text was: {data}")
    except WebSocketDisconnect:
        print("Client disconnected")
```

### WebSocket with Connection Manager
```python
class ConnectionManager:
    def __init__(self):
        self.active_connections: list[WebSocket] = []

    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)

    def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)

    async def send_personal_message(self, message: str, websocket: WebSocket):
        await websocket.send_text(message)

    async def broadcast(self, message: str):
        for connection in self.active_connections:
            await connection.send_text(message)

manager = ConnectionManager()

@app.websocket("/ws/{client_id}")
async def websocket_endpoint(websocket: WebSocket, client_id: int):
    await manager.connect(websocket)
    try:
        while True:
            data = await websocket.receive_text()
            await manager.send_personal_message(f"You wrote: {data}", websocket)
            await manager.broadcast(f"Client #{client_id} says: {data}")
    except WebSocketDisconnect:
        manager.disconnect(websocket)
        await manager.broadcast(f"Client #{client_id} left the chat")
```

## Background Tasks

### Simple Background Tasks
```python
from fastapi import BackgroundTasks

def write_log(message: str):
    with open("log.txt", "a") as f:
        f.write(message)

@app.post("/send-notification/{email}")
def send_notification(email: str, background_tasks: BackgroundTasks):
    background_tasks.add_task(write_log, f"Notification sent to {email}")
    return {"message": "Notification sent in the background"}
```

### Multiple Background Tasks
```python
def process_data(data: dict):
    # Process data in background
    pass

def send_email(email: str, message: str):
    # Send email in background
    pass

@app.post("/process/")
def process_items(
    items: list[Item],
    background_tasks: BackgroundTasks
):
    for item in items:
        background_tasks.add_task(process_data, item.dict())
        background_tasks.add_task(send_email, "admin@example.com", f"Processed {item.name}")
    return {"message": "Processing started"}
```

## Testing

### TestClient
```python
from fastapi.testclient import TestClient

client = TestClient(app)

def test_read_main():
    response = client.get("/")
    assert response.status_code == 200
    assert response.json() == {"Hello": "World"}

def test_create_item():
    response = client.post(
        "/items/",
        json={"name": "Test Item", "price": 10.5}
    )
    assert response.status_code == 200
    assert response.json()["name"] == "Test Item"
```

### Async Testing
```python
import pytest
from httpx import AsyncClient

@pytest.mark.asyncio
async def test_read_items():
    async with AsyncClient(app=app, base_url="http://test") as ac:
        response = await ac.get("/items/")
    assert response.status_code == 200
```

## Advanced Features

### Custom Response Classes
```python
from fastapi import FastAPI
from fastapi.responses import HTMLResponse, JSONResponse, StreamingResponse

@app.get("/html/", response_class=HTMLResponse)
def read_html():
    return """
    <html>
        <head>
            <title>Some HTML</title>
        </head>
        <body>
            <h1>Look! HTML!</h1>
        </body>
    </html>
    """

@app.get("/custom-json/")
def read_custom_json():
    return JSONResponse(
        content={"message": "Custom JSON"},
        status_code=201,
        headers={"X-Custom-Header": "Custom Value"}
    )
```

### Request and Response Models
```python
from fastapi import Request
from fastapi.responses import Response

@app.get("/request-info/")
def read_request_info(request: Request):
    return {
        "url": request.url,
        "method": request.method,
        "headers": dict(request.headers),
        "client": request.client.host if request.client else None
    }

@app.get("/custom-response/")
def read_custom_response():
    return Response(
        content="Custom response content",
        media_type="text/plain",
        headers={"X-Custom": "Header"}
    )
```

### Dependency Overrides
```python
from fastapi.testclient import TestClient

def override_get_db():
    return FakeDatabase()

app.dependency_overrides[get_db] = override_get_db

client = TestClient(app)
# Now all tests will use FakeDatabase instead of real database
```

FastAPI provides a comprehensive set of features for building modern, high-performance APIs with excellent developer experience and automatic documentation.

---

*Source: [https://fastapi.tiangolo.com/features/](https://fastapi.tiangolo.com/features/)*
description:
globs:
alwaysApply: false
---
